{"mappings":"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","sources":["<anon>","src/workers/pdfWorker.ts","src/pdf.ts"],"sourcesContent":["(() => {\n\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequireed96\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequireed96\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"do4eo\", function(module, exports) {\n\nvar $hO6Jd = parcelRequire(\"hO6Jd\");\nself.onmessage = async (evt)=>{\n    try {\n        const images = evt.data;\n        // Generate the PDF (Uint8Array) off the main thread\n        const pdfUint8 = await (0, $hO6Jd.toPDF)(images);\n        // Transfer the underlying buffer back to main thread\n        postMessage(pdfUint8.buffer, [\n            pdfUint8.buffer\n        ]);\n    } catch (err) {\n        const message = err instanceof Error ? err.message : String(err);\n        postMessage({\n            error: message\n        });\n    }\n};\n\n});\nparcelRegister(\"hO6Jd\", function(module, exports) {\n\n$parcel$export(module.exports, \"toPDF\", () => $394b68a7569c0efa$export$99fdcdff3bb1ad24);\n/// <reference lib=\"dom\" />\n/// <reference lib=\"es2017\" />\n// In browser/worker, process may not exist; guard its usage\nconst $394b68a7569c0efa$var$readFile = Blob.prototype.arrayBuffer || function() {\n    return new Promise((resolve, reject)=>{\n        const fr = new FileReader();\n        fr.onload = ()=>{\n            resolve(fr.result);\n        };\n        fr.onerror = ()=>{\n            reject(fr.error);\n        };\n        fr.readAsArrayBuffer(this);\n    });\n};\nconst $394b68a7569c0efa$export$99fdcdff3bb1ad24 = async (images)=>{\n    const pdfChunks = [];\n    let index = 0;\n    const offsets = [];\n    const write = (chunk)=>{\n        pdfChunks.push(chunk);\n        index += chunk.length;\n    };\n    const token = (chunk)=>{\n        write(\" \");\n        write(chunk);\n    };\n    const concat = (chunks)=>{\n        let len = 0;\n        for (const chunk of chunks)len += chunk.length;\n        const buf = new Uint8Array(len);\n        len = 0;\n        for (const chunk of chunks){\n            if (typeof chunk == \"string\") for(let i = 0; i < chunk.length; ++i)buf[i + len] = chunk.charCodeAt(i);\n            else buf.set(chunk, len);\n            len += chunk.length;\n        }\n        return buf;\n    };\n    // Convenience functions\n    const comment = (content)=>{\n        write(\"%\" + content + \"\\n\");\n    };\n    const number = (value)=>{\n        // Note: this doesnt work for very small and very large numbers\n        token(value.toString());\n    };\n    const ascii = (value)=>{\n        token(\"(\" + value.replace(/[\\n\\r\\t\\f\\b\\(\\)\\\\]/g, (c)=>\"\\\\00\" + c.charCodeAt(0).toString(8)) + \")\");\n    };\n    const bin = (value)=>{\n        let data = \"<\";\n        if (typeof value == \"string\") for(let i = 0; i < value.length; ++i)data += value.charCodeAt(i).toString(16);\n        else for(let i = 0; i < value.length; ++i)data += value[i].toString(16);\n        token(data + \">\");\n    };\n    const name = (value)=>{\n        // Note: only supports ASCII names\n        token(\"/\" + value);\n    };\n    const array = (fn)=>{\n        token(\"[\");\n        fn();\n        token(\"]\");\n    };\n    const dict = (values)=>{\n        token(\"<<\");\n        for(const key in values){\n            name(key);\n            values[key]();\n        }\n        token(\">>\");\n    };\n    const stream = (desc, content)=>{\n        // Only assert in non-production when process.env is available\n        if (typeof process !== \"undefined\" && process.env != null && process.env.NODE_ENV !== \"production\") {\n            if (!desc[\"Length\"]) throw new TypeError(\"need stream length\");\n        }\n        dict(desc);\n        token(\"stream\\n\");\n        write(content);\n        write(\"endstream\");\n    };\n    const object = (fn)=>{\n        write(\" \");\n        write(offsets.push(index) + \" 0 obj\");\n        fn();\n        token(\"endobj\");\n        return offsets.length;\n    };\n    const reference = (id)=>{\n        token(id + \" 0 R\");\n    };\n    const nullObject = ()=>{\n        token(\"null\");\n    };\n    // v1.4 for compatibility\n    comment(\"PDF-1.4\");\n    // 4 byte binary comment, as suggested by spec\n    comment(\"\\x90\\x85\\xfa\\xe3\");\n    const pagesRootId = images.length * 3 + 1;\n    const pages = await Promise.all(images.map(async (img)=>{\n        // Convert ImageData to JPEG binary\n        let jpegBlob;\n        if (typeof OffscreenCanvas !== \"undefined\") {\n            const offscreen = new OffscreenCanvas(img.width, img.height);\n            const ctx = offscreen.getContext(\"2d\");\n            ctx.putImageData(img, 0, 0);\n            jpegBlob = await offscreen.convertToBlob({\n                type: \"image/jpeg\"\n            });\n        } else if (typeof document !== \"undefined\") {\n            const htmlCanvas = document.createElement(\"canvas\");\n            htmlCanvas.width = img.width;\n            htmlCanvas.height = img.height;\n            const ctx = htmlCanvas.getContext(\"2d\");\n            ctx.putImageData(img, 0, 0);\n            jpegBlob = await new Promise((resolve)=>htmlCanvas.toBlob(resolve, \"image/jpeg\"));\n        } else throw new Error(\"Cannot generate JPEG: no canvas or document available in worker context\");\n        const jpegData = new Uint8Array(await $394b68a7569c0efa$var$readFile.call(jpegBlob));\n        const image = object(()=>{\n            stream({\n                Type () {\n                    name(\"XObject\");\n                },\n                Subtype () {\n                    name(\"Image\");\n                },\n                Width () {\n                    number(img.width);\n                },\n                Height () {\n                    number(img.height);\n                },\n                ColorSpace () {\n                    name(\"DeviceRGB\");\n                },\n                BitsPerComponent () {\n                    number(8);\n                },\n                Filter () {\n                    name(\"DCTDecode\");\n                },\n                Length () {\n                    number(jpegData.length);\n                }\n            }, jpegData);\n        });\n        // US Letter width\n        const height = 792;\n        const width = height * img.width / img.height;\n        const contents = object(()=>{\n            const result = `${width} 0 0 ${height} 0 0 cm /I Do`;\n            stream({\n                Length () {\n                    number(result.length);\n                }\n            }, concat([\n                result\n            ]));\n        });\n        const page = object(()=>{\n            dict({\n                Type () {\n                    name(\"Page\");\n                },\n                Parent () {\n                    reference(pagesRootId);\n                },\n                Resources () {\n                    dict({\n                        XObject () {\n                            dict({\n                                I () {\n                                    reference(image);\n                                }\n                            });\n                        }\n                    });\n                },\n                Contents () {\n                    reference(contents);\n                },\n                MediaBox () {\n                    array(()=>{\n                        number(0);\n                        number(0);\n                        number(width);\n                        number(height);\n                    });\n                }\n            });\n        });\n        return page;\n    }));\n    const pageRoot = object(()=>{\n        dict({\n            Type () {\n                name(\"Pages\");\n            },\n            Kids () {\n                array(()=>{\n                    for (const page of pages)reference(page);\n                });\n            },\n            Count () {\n                number(pages.length);\n            }\n        });\n    });\n    const catalog = object(()=>{\n        dict({\n            Type () {\n                name(\"Catalog\");\n            },\n            Pages () {\n                reference(pageRoot);\n            }\n        });\n    });\n    // XREF\n    write(\"\\n\");\n    const xrefOffset = index;\n    write(\"xref\\n0 \" + (offsets.length + 1) + \"\\n0000000000 65535 f \\n\");\n    for (const offset of offsets)write(offset.toString().padStart(10, \"0\") + \" 00000 n \\n\");\n    write(\"trailer\");\n    dict({\n        Size () {\n            number(offsets.length + 1);\n        },\n        Root () {\n            reference(catalog);\n        }\n    });\n    write(\"\\nstartxref\\n\" + xrefOffset + \"\\n%%EOF\");\n    return concat(pdfChunks);\n};\n\n});\n\n\n\nparcelRequire(\"do4eo\");\n})();\n//# sourceMappingURL=pdfWorker.e9b60806.js.map\n","import { toPDF } from \"../pdf\";\n\ndeclare const self: DedicatedWorkerGlobalScope;\n\nself.onmessage = async (evt: MessageEvent<ImageData[]>) => {\n  try {\n    const images = evt.data;\n    // Generate the PDF (Uint8Array) off the main thread\n    const pdfUint8 = await toPDF(images);\n    // Transfer the underlying buffer back to main thread\n    postMessage(pdfUint8.buffer, [pdfUint8.buffer]);\n  } catch (err) {\n    const message = err instanceof Error ? err.message : String(err);\n    postMessage({ error: message });\n  }\n};\n","/// <reference lib=\"dom\" />\n/// <reference lib=\"es2017\" />\n// In browser/worker, process may not exist; guard its usage\ndeclare const process: any;\n\nconst readFile =\n  Blob.prototype.arrayBuffer ||\n  function (this: Blob) {\n    return new Promise((resolve, reject) => {\n      const fr = new FileReader();\n      fr.onload = () => {\n        resolve(fr.result as ArrayBuffer);\n      };\n      fr.onerror = () => {\n        reject(fr.error);\n      };\n      fr.readAsArrayBuffer(this);\n    });\n  };\n\nexport const toPDF = async (images: ImageData[]) => {\n  const pdfChunks: (string | ArrayLike<number>)[] = [];\n  let index = 0;\n  const offsets: number[] = [];\n  const write = (chunk: string | ArrayLike<number>) => {\n    pdfChunks.push(chunk);\n    index += chunk.length;\n  };\n  const token = (chunk: string | ArrayLike<number>) => {\n    write(\" \");\n    write(chunk);\n  };\n  const concat = (chunks: (string | ArrayLike<number>)[]) => {\n    let len = 0;\n    for (const chunk of chunks) len += chunk.length;\n    const buf = new Uint8Array(len);\n    len = 0;\n    for (const chunk of chunks) {\n      if (typeof chunk == \"string\") {\n        for (let i = 0; i < chunk.length; ++i)\n          buf[i + len] = chunk.charCodeAt(i);\n      } else {\n        buf.set(chunk, len);\n      }\n      len += chunk.length;\n    }\n    return buf;\n  };\n  // Convenience functions\n  const comment = (content: string) => {\n    write(\"%\" + content + \"\\n\");\n  };\n  const number = (value: number) => {\n    // Note: this doesnt work for very small and very large numbers\n    token(value.toString());\n  };\n  const ascii = (value: string) => {\n    token(\n      \"(\" +\n        value.replace(\n          /[\\n\\r\\t\\f\\b\\(\\)\\\\]/g,\n          (c) => \"\\\\00\" + c.charCodeAt(0).toString(8)\n        ) +\n        \")\"\n    );\n  };\n  const bin = (value: string | ArrayLike<number>) => {\n    let data = \"<\";\n    if (typeof value == \"string\") {\n      for (let i = 0; i < value.length; ++i) {\n        data += value.charCodeAt(i).toString(16);\n      }\n    } else {\n      for (let i = 0; i < value.length; ++i) {\n        data += value[i].toString(16);\n      }\n    }\n    token(data + \">\");\n  };\n  const name = (value: string) => {\n    // Note: only supports ASCII names\n    token(\"/\" + value);\n  };\n  const array = (fn: () => void) => {\n    token(\"[\");\n    fn();\n    token(\"]\");\n  };\n  type Dict = Record<string, () => void>;\n  const dict = (values: Dict) => {\n    token(\"<<\");\n    for (const key in values) {\n      name(key);\n      values[key]();\n    }\n    token(\">>\");\n  };\n  const stream = (desc: Dict, content: ArrayLike<number>) => {\n    // Only assert in non-production when process.env is available\n    if (\n      typeof process !== \"undefined\" &&\n      process.env != null &&\n      process.env.NODE_ENV !== \"production\"\n    ) {\n      if (!desc[\"Length\"]) throw new TypeError(\"need stream length\");\n    }\n    dict(desc);\n    token(\"stream\\n\");\n    write(content);\n    write(\"endstream\");\n  };\n  const object = (fn: () => void) => {\n    write(\" \");\n    write(offsets.push(index) + \" 0 obj\");\n    fn();\n    token(\"endobj\");\n    return offsets.length;\n  };\n  const reference = (id: number) => {\n    token(id + \" 0 R\");\n  };\n  const nullObject = () => {\n    token(\"null\");\n  };\n\n  // v1.4 for compatibility\n  comment(\"PDF-1.4\");\n  // 4 byte binary comment, as suggested by spec\n  comment(\"\\x90\\x85\\xfa\\xe3\");\n  const pagesRootId = images.length * 3 + 1;\n  const pages = await Promise.all(\n    images.map(async (img) => {\n      // Convert ImageData to JPEG binary\n      let jpegBlob: Blob;\n      if (typeof OffscreenCanvas !== \"undefined\") {\n        const offscreen = new OffscreenCanvas(img.width, img.height);\n        const ctx = offscreen.getContext(\"2d\")!;\n        ctx.putImageData(img, 0, 0);\n        jpegBlob = await offscreen.convertToBlob({ type: \"image/jpeg\" });\n      } else if (typeof document !== \"undefined\") {\n        const htmlCanvas = document.createElement(\"canvas\");\n        htmlCanvas.width = img.width;\n        htmlCanvas.height = img.height;\n        const ctx = htmlCanvas.getContext(\"2d\")!;\n        ctx.putImageData(img, 0, 0);\n        jpegBlob = (await new Promise<Blob | null>((resolve) =>\n          htmlCanvas.toBlob(resolve, \"image/jpeg\")\n        ))!;\n      } else {\n        throw new Error(\n          \"Cannot generate JPEG: no canvas or document available in worker context\"\n        );\n      }\n      const jpegData = new Uint8Array(await readFile.call(jpegBlob));\n      const image = object(() => {\n        stream(\n          {\n            Type() {\n              name(\"XObject\");\n            },\n            Subtype() {\n              name(\"Image\");\n            },\n            Width() {\n              number(img.width);\n            },\n            Height() {\n              number(img.height);\n            },\n            ColorSpace() {\n              name(\"DeviceRGB\");\n            },\n            BitsPerComponent() {\n              number(8);\n            },\n            Filter() {\n              name(\"DCTDecode\");\n            },\n            Length() {\n              number(jpegData.length);\n            },\n          },\n          jpegData\n        );\n      });\n      // US Letter width\n      const height = 792;\n      const width = (height * img.width) / img.height;\n      const contents = object(() => {\n        const result = `${width} 0 0 ${height} 0 0 cm /I Do`;\n        stream(\n          {\n            Length() {\n              number(result.length);\n            },\n          },\n          concat([result])\n        );\n      });\n      const page = object(() => {\n        dict({\n          Type() {\n            name(\"Page\");\n          },\n          Parent() {\n            reference(pagesRootId);\n          },\n          Resources() {\n            dict({\n              XObject() {\n                dict({\n                  I() {\n                    reference(image);\n                  },\n                });\n              },\n            });\n          },\n          Contents() {\n            reference(contents);\n          },\n          MediaBox() {\n            array(() => {\n              number(0);\n              number(0);\n              number(width);\n              number(height);\n            });\n          },\n        });\n      });\n      return page;\n    })\n  );\n\n  const pageRoot = object(() => {\n    dict({\n      Type() {\n        name(\"Pages\");\n      },\n      Kids() {\n        array(() => {\n          for (const page of pages) {\n            reference(page);\n          }\n        });\n      },\n      Count() {\n        number(pages.length);\n      },\n    });\n  });\n\n  const catalog = object(() => {\n    dict({\n      Type() {\n        name(\"Catalog\");\n      },\n      Pages() {\n        reference(pageRoot);\n      },\n    });\n  });\n\n  // XREF\n  write(\"\\n\");\n  const xrefOffset = index;\n  write(\"xref\\n0 \" + (offsets.length + 1) + \"\\n0000000000 65535 f \\n\");\n  for (const offset of offsets) {\n    write(offset.toString().padStart(10, \"0\") + \" 00000 n \\n\");\n  }\n  write(\"trailer\");\n  dict({\n    Size() {\n      number(offsets.length + 1);\n    },\n    Root() {\n      reference(catalog);\n    },\n  });\n  write(\"\\nstartxref\\n\" + xrefOffset + \"\\n%%EOF\");\n  return concat(pdfChunks);\n};\n"],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","$hO6Jd","self","onmessage","evt","images","data","pdfUint8","toPDF","postMessage","buffer","error","message","String","Object","defineProperty","get","$394b68a7569c0efa$export$99fdcdff3bb1ad24","set","s","enumerable","configurable","$394b68a7569c0efa$var$readFile","Blob","prototype","arrayBuffer","Promise","resolve","reject","fr","FileReader","onload","result","onerror","readAsArrayBuffer","pdfChunks","index","offsets","write","chunk","push","length","token","concat","chunks","len","buf","Uint8Array","i","charCodeAt","comment","content","number","value","toString","name","array","fn","dict","values","key","stream","desc","process","env","NODE_ENV","TypeError","object","reference","pagesRootId","pages","all","map","img","jpegBlob","OffscreenCanvas","offscreen","width","height","ctx","getContext","putImageData","convertToBlob","type","document","htmlCanvas","createElement","toBlob","jpegData","image","Type","Subtype","Width","Height","ColorSpace","BitsPerComponent","Filter","Length","contents","Parent","Resources","XObject","I","Contents","MediaBox","pageRoot","Kids","page","Count","catalog","Pages","xrefOffset","offset","padStart","Size","Root"],"version":3,"file":"pdfWorker.e9b60806.js.map"}